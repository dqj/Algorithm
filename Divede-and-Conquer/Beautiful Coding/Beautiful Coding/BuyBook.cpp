/*========================************************===============================
则在最优解中有如下性质:
1 所有只包含一本书的组均只包含同一本书
  若有两组包含一本书的组包含的书不同,则这两组合并,能得到更优解,与最优解矛盾.
2 包含一本书的组只包含A
  若包含书为A',若Na'==Na,则A,A'对调即可
  若Na'<Na,则必存在某组包含A不包含A',则将只包含A'的组并入该组能得到更优解

3 所有只包含两本书的组均包含相同两本书
  组(A', B'), (A',C')折扣0.2重组为(A',B',C')与(A)折扣0.3

4 包含两本书的组必包含A
  若存在包含一本A的组,而两本书的组不包含A,则合并能得更优解
  若不存在包含一本A的组,而两本书组包含为A',A'',则包含三本书,四本组必含A而缺A'者
  (A', A''), (AXY), 折扣0.4不如(A''),(AXYA')0.8
  (A',A''),(AXYZ)折扣0.9不如(A''),(AXYZA')1.25

5 包含两本书的组必包含B,同上证
 
6 所有只包含三本书的组均包含相同三本书
  (A,B,C),(A,B,D)折扣0.6,(A,B),(A,B,C,D)折扣0.9

7 所有包含三本书的组均包含A
  若存在只包含A的组,合并得更优
  若存在只包含A, B的组(A,B)(XYZ)折扣0.4,不如(B)(AXYZ)折扣0.8
  若不存在一,二本组,假设三本书组为(X,Y,Z),则必有包含A的四本组缺X,(X,Y,Z)(A,A',A'',A''')折扣1.1,不如
  (Y,Z),(A,A',A'',A''',X)折扣1.35

8 所有包含三本的组均包含B,C,同上可证

9 所有包含四本书的组均包含A,B,C
  设XYZW为(ABC)(BCDE)折扣1.1,不如(B,C),(A,B,C,D,E)折扣1.35
  其它情况同理可证

10 包含五本书与包含三本书情况不会同时出现
   (A,B,C),(A,B,C,D,E)折扣1.55,不如(A,B,C,D),(A,B,C,E)折扣1.6

由以上证明可得如下结论
每组均包含A,所有组数与A相同
所有包含两本及以上的组均包含B,组数与B同
所有包含三本及以上的组均包含C,组数与C同
三,五不并存
=================================****************************===============================
*/
/*=======double和float占字节数不同,其中double为8个字节，而float为4个字节============
===============两者的精度不同 float->double 可行 其逆将会丢失精度===================
===============正是这种精度的不同，造成了下面和的不对。=============================*/
#include "BuyBook.h"
const double UNIT_PRICE = 8;
const double DISCOUNTS[5] = {1, 0.95, 0.9, 0.8, 0.75};
static const int BOOK_KINDS = 5;
CBuyBook::CBuyBook(void)
{
}

CBuyBook::~CBuyBook(void)
{
}

float CBuyBook::SearchFast(int* books)
{
	SelectSort(books,5);
    int g[5];
    g[0] = books[0] - books[1];
    g[1] = books[1] - books[2];
    g[2] = books[2] - books[3];
    g[3] = books[3] - books[4];
    g[4] = books[4];
	//
    int t = min(g[2], g[4]);
    if (t > 0)
    {
        g[2] -= t;
        g[4] -= t;
        g[3] += 2 * t;
    }
    float sum = 0;
    for (int i = 0; i < BOOK_KINDS; ++i)
    {
        sum += g[i] * (i+1) * UNIT_PRICE * DISCOUNTS[i];
    }
    return sum;
}
